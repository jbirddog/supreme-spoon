from util import by_id

class PythonCPSBackend:
    @classmethod
    def codegen(self, kinda_ast):
        steps = kinda_ast[0][2]
        start_event = list(filter(lambda n: n[0] == "startEvent", steps))[0]
        steps_by_id = by_id(steps)

        func_map = {
            "endEvent": "end_event",
            "manualTask": "manual_task",
            "parallelGateway": "parallel_gateway",
            "scriptTask": "script_task",
            "startEvent": "start_event",
        }

        def outgoing(step):
            return list(filter(lambda n: n[0] == "outgoing", step[2]))

        def form_cps_steps(step):
            def _form_cps_steps(step, steps, seen):
                id = step[1]["id"]
                if id in seen:
                    return
                f = func_map[step[0]]
                config = step[2]
                outgoing_steps = map(lambda s: steps_by_id[s[2]], outgoing(step))
                ks = []
                for outgoing_step in outgoing_steps:
                    _form_cps_steps(outgoing_step, steps, seen)
                    ks.append(outgoing_step[1]["id"])
                steps.append((f, id, config, ks))
                seen.add(id)
                return steps
            return _form_cps_steps(step, [], set())

        steps = form_cps_steps(start_event)
        process_id = kinda_ast[0][1]["id"]
        code = "\n".join([
            Templates.preamble(), 
            Templates.cps_steps(steps),
            Templates.main(process_id, start_event[1]["id"]),
        ])

        return code

#
# Templates for generated file
#

class Templates:
    @staticmethod
    def cps_steps(steps):
        def _code_str(step):
            (f, id, config, ks) = step
            ks = list(map(lambda k_id: f"__k(\"{k_id}\")", ks))
            ks_len = len(ks)
            if ks_len == 0:
                k = "end_k"
            elif ks_len > 1:
                k = f"fan_out([{', '.join(ks)}])"
            else:
                k = ks[0]
            cps = f"steps[\"{id}\"] = {f}(\"{id}\", {config}, {k})"
            return cps
        steps = map(_code_str, steps)
        step_decls = "\n".join(steps)
        return f"""
steps = {{}}
__k = lambda id: steps[id]

{step_decls}
"""
    @staticmethod
    def main(process_id, step_id):
        return f"""

#
# Workflow expressed in CPS style. Would allow starting from/resuming at any point
#
workflow = steps["{step_id}"]

if __name__ == "__main__":
    print("Running '{process_id}'...")
    
    workflow({{}})
"""

    def preamble():
        # TODO only build preamble with what is needed by the workflow
        # TODO strategy for splitting these out into "lib" packages available to the
        #   compiled program.
        #
        #   from supreme_spoon.python_csp.runtime import fan_out, identity
        #   from supreme_spoon.python_cps.cli import manual_task
        #
        #   currently we have "static linking", perhaps keep that as an option as well.
        return """
# GENERATED BY supreme-spoon

#
# This is an early POC to demonstrate compiling BPMN diagrams to a static Python file.
#

#
# Example runtime
#

def configs_named(config, name):
    return list(filter(lambda c: c[0] == name, config))

def config_named(config, name):
    return configs_named(config, name)[0]

def config_value_named(config, name):
    return config_named(config, name)[2]

def ext_named(config, ext_name):
    ext_elems = config_named(config, 'extensionElements')
    return configs_named(ext_elems[2], ext_name)[0]

def ext_value_named(config, ext_name):
    return ext_named(config, ext_name)[2]

def fan_out(ks):
    def impl(data):
        results = [k(data) for k in ks]
        for result in results:
            if result is not None:
                return result
    return impl

def end_k(data):
    print("Complete!")
    print(f"data: {data}")


#
# Example bpmn element implementations
#

def end_event(id, config, k):
    def impl(data):
        print(f"In end_event: {id}")
        k(data)
    return impl

def manual_task(id, config, k):
    import os
    prompt = ext_value_named(config, 'instructionsForEndUser')
    def impl(data):
        print(f"In manual_task: {id}")
        input(prompt)
        print(config)
        k(data)
    return impl

pg_instances = {}
def parallel_gateway(id, config, k):
    def make():
        expected_in = len(configs_named(config, 'incoming'))
        conds = {"let_in": 0}

        def impl(data):
            assert conds["let_in"] < expected_in
            conds["let_in"] += 1
            if conds["let_in"] == expected_in:
                print(f"In parallel_gateway: {id}")
                k(data)
        return impl
    if id not in pg_instances:
        pg_instances[id] = make()
    return pg_instances[id]

def script_task(id, config, k):
    script = config_value_named(config, 'script')
    def impl(data):
        print(f"In script_task: {id} - {script}")
        data[f"result_{id}"] = f"TODO_EVAL({script})"
        k(data)
    return impl

def start_event(id, config, k):
    def impl(data):
        print(f"In start_event: {id}")
        k(data)
    return impl
"""
