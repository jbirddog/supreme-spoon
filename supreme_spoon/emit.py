
class Emitter:

    @classmethod
    def spec_converter_imports(cls, spec_converters):
        def build_import(sc):
            return f"from SpiffWorkflow.spiff.serializer.task_spec_converters import {sc}"

        return "\n".join(map(build_import, spec_converters))

    @classmethod
    def spec_converters_array(cls, spec_converters):
        return f"[{', '.join(spec_converters)}]"

    @classmethod
    def build_imports(cls, spec_converters, spec_types):
        imports = []

        if "Script Task" in spec_types:
            imports.append("from SpiffWorkflow.bpmn.PythonScriptEngine import PythonScriptEngine")

        imports.append("from SpiffWorkflow.bpmn.serializer.workflow import BpmnWorkflowSerializer")

        for spec_converter in spec_converters:
            imports.append(f"from SpiffWorkflow.spiff.serializer.task_spec_converters import {spec_converter}")

        return "\n".join(imports)

    @classmethod
    def emit(cls, 
        class_name, 
        serialized_workflow, 
        serializer_version, 
        spec_converters, 
        spec_types,
        grouped_task_metadata, 
        output_filename
    ):
        imports = cls.build_imports(spec_converters, spec_types)
        sc_array = cls.spec_converters_array(spec_converters)
        with open(output_filename, "w") as f:
            f.write(f"""# GENERATED by Supreme Spoon

{imports}


class {class_name}:
    def __init__(self, scripting_additions=None):
        self.scripting_additions = scripting_additions

    def get_serializer(self):
        spec_converters = {sc_array}
        spec_converter = BpmnWorkflowSerializer.configure_workflow_spec_converter(spec_converters)
        serializer = BpmnWorkflowSerializer(spec_converter, version="{serializer_version}")
        return serializer

    # TODO: restore
    def get_workflow(self):
        workflow = self.get_serializer().workflow_from_dict(self.SERIALIZED_WORKFLOW)

        if self.scripting_additions is not None:
            workflow.script_engine = PythonScriptEngine(scripting_additions=self.scripting_additions)

        return workflow

    def run(self):
        workflow = self.get_workflow()
        workflow.do_engine_steps()
        while not workflow.is_completed():
            ready_tasks = workflow.get_ready_user_tasks()
            for task in ready_tasks:
                task.complete()
            workflow.refresh_waiting_tasks()
            workflow.do_engine_steps()

        return workflow.data

    SERIALIZED_WORKFLOW = {serialized_workflow}
""")
